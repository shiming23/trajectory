x.synthesis.data <- function(){
  # generate x shape data of totally 1000 point in [0,1]*[0,1] region
  x1 = runif(500)
  y1 = x1+ rnorm(length(x1), sd = 0.05)
  
  x2 = runif(500)
  y2 = 1-x2+ rnorm(length(x2), sd = 0.05)
  
  return(rbind(cbind(x1,y1), cbind(x2,y2)))
}

ellipse.synthesis.data <- function(a = 2,b = 1){
  
  #a and b is the two main axises of the ellipse
  
  theta <- runif(500)*2*pi
  
  radius.theta <- runif(length(theta))
  
  x <- a*radius.theta*cos(theta)#+rnorm(length(theta), sd = 0.05)
  
  y <- b*radius.theta*sin(theta)# +rnorm(length(theta), sd = 0.05)
  
  return(cbind(x,y))
}

circle.synthesis.data <- function(num=num){

  theta <- runif(num)*2*pi
  
  x <- cos(theta)+rnorm(length(theta), sd = 0.05)
  
  y <- sin(theta)+rnorm(length(theta), sd = 0.05)
  
  return(cbind(x,y))
  
}

micdat.lin <- function(num=1000){
  
  x = runif(num, min = 0, max = 1)
  
  y = x
  
  return(cbind(x,y))
  
}

micdat.para <- function(num =1000){
  
  x = runif(num, min = 0, max = 1)
   
  y = 4*(x-1/2)^2
  
  return(cbind(x,y))
  
}

micdat.cubic <- function(num=1000){
  
  x = runif(num, min = 0, max = 1)
  
  y =  128*(x-1/3)^3 - 48*(x-1/3)^2 -12*(x-1/3) +2
  
  return(cbind(x,y))
  
}

micdat.expo <- function(num =1000){
  
  x = runif(num, min = 0, max = 1)
  
  y =  10^(10*x) -1
  
  return(cbind(x,y))
}

micdat.linper <- function(num =1000){
  
  x = runif(num, min = 0, max = 1)
  
  y =  sin(10*3.1415926*x)+x
  
  return(cbind(x,y))
}

micdat.sinf <- function(num =1000){
  
  x = runif(num, min = 0, max = 1)
  
  y =  sin(16*3.1415926*x)
  
  return(cbind(x,y))
}

micdat.cat <- function(num =64){
  
  # 64 random points for 4 categories
  
  oripoins = matrix(c(1,0.287,2,0.796,3,0.290,4,0.924,5,0.717), ncol = 2, byrow = T)
  
  randpoins = sample(c(1:4), num, replace = T)
  
  x = oripoins[randpoins,1]
  
  y =  oripoins[randpoins,2]
  
  return(cbind(x,y))
}

toy.line <- function(num=100){
  
  x = runif(num, 0, 1)
  
  y = 0
  
  return(cbind(x,y))
  
}

toy.sine <- function(num=100){
# version 1
  #x = runif(num,0,1)
  
  #y = sin(8*pi*x)
  
  #return(cbind(x,y))
# version 2, importance sampling, 2020-04-17  
  x <- runif(num, 0, 1)
  
  y <- runif(num, 0, sqrt(64*pi^2+1))
  
  # fx = sin(8*pi*x)
  
  diffx <- 8*pi*cos(8*pi*x)
  
  ind <- (y<= sqrt(1+diffx^2))
  
  x2 <- x[ind]
   
  y2 <- sin(8*pi*x2)
  
  return(cbind(x2, y2))
}

toy.cross <- function(num=100){
  
  num2 <- round(num/2)
  
  x <- runif(num2, 0,1)
  
  y <- runif(num2, 0,1)
  
  rbind(cbind(x,1/2), cbind(1/2, y))
  
}

toy.tree <- function(num=100){
  
  num1 <- round(num*1/(1+2*sqrt(2)))
  
  x1 <- rep(0.5, num1)
  
  y1 <- runif(num1, 0, 1)
  
  num2 <- round(num*sqrt(2)/(1+2*sqrt(2)))
  
  x2 <- runif(num2,0,1)
  
  y2 <- abs(x2-0.5)
  
  x3 <- runif(num2, 0,1)
  
  y3 <- abs(x3-0.5)+0.5
  
  return(cbind(c(x1,x2,x3), c(y1,y2,y3)))
  
}

toy.disc <- function(num=100){
#version 1
#  r <- runif(num,0,1)
  
#  theta <- runif(num,0,2*pi)
  
#  x <- r*cos(theta)
  
#  y <- r*sin(theta)
  
#  return(cbind(x,y))

# version 2020-04-07 Importance sampling
  
  x <- runif(num, -1, 1)
  
  y <- runif(num, -1, 1)
  
  ind <- x^2 +y^2 <= 1
  
  return(cbind(x[ind], y[ind]))
    
}

toy.segment1 <- function(theta=1/3*pi, num=100){
# generated by Rejection sampling, PRML-cHAPTER 11.1.2  
  x <- runif(num*8/theta, -1, 1)
  
  y <- runif(num*8/theta, -1, 1)
  
  cosx <- x/sqrt(x^2+y^2)
  
  siny <- y/sqrt(x^2+y^2)
  
  ind <- (x^2+y^2<=1) & ( cosx>=cos(theta) ) &( siny>0) 
  
  return(cbind(x[ind],y[ind]))
  
}

toy.segment2 <- function(theta=3/2*pi, num=100){
  
  # generated by Rejection sampling, PRML-cHAPTER 11.1.2  
  
  x <- runif(num*8/theta, -1, 1)
  
  y <- runif(num*8/theta, -1, 1)
  
  cosx <- x/sqrt(x^2+y^2)
  
  siny <- y/sqrt(x^2+y^2)
  
  ind <- (x^2+y^2<=1) & (siny>=0 | ( siny <0 & (cosx<=cos(theta))) )
  
  return(cbind(x[ind],y[ind]))
  
}
# contructed at 26-Mar-2021
# toy.sectorlpi <- function(theta=1/2*pi, num=100){
#   # sector with angle less than pi
#   # generated by Rejection sampling, PRML-cHAPTER 11.1.2  
#   
#   x <- runif(num*2*pi/theta,-1,1)
#   
#   y <- runif(num*2*pi/theta, -1, 1)
#   
#   id0 <- (x^2+y^2)<1
#   id1 <- y>0
#   id2 <- (x*sin(theta)-y*sin(theta) )<0
#   
#   idsum <- id0&id1&id2
#   
#   return(cbind(x[idsum],y[idsum]))
#   
#   
#   
# }

